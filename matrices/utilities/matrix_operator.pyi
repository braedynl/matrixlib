from typing import Any, Literal, Protocol, TypeVar, overload

from ..abc import MatrixLike
from .matrix_map import MatrixMap
from .matrix_product import MatrixProduct

__all__ = [
    "compare",
    "__lt__",
    "__le__",
    "__eq__",
    "__ne__",
    "__gt__",
    "__ge__",
    "__add__",
    "__sub__",
    "__mul__",
    "__truediv__",
    "__floordiv__",
    "__mod__",
    "__divmod__",
    "__lshift__",
    "__rshift__",
    "__neg__",
    "__pos__",
    "__abs__",
    "__and__",
    "__xor__",
    "__or__",
    "__invert__",
    "__matmul__",
    "conjugate",
]

S = TypeVar("S")

T = TypeVar("T")
T_co = TypeVar("T_co", covariant=True)
T_contra = TypeVar("T_contra", contravariant=True)

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)
P = TypeVar("P", bound=int)

ComplexT = TypeVar("ComplexT", bound=complex)


class SupportsAdd(Protocol[T_contra, T_co]):
    def __add__(self, other: T_contra) -> T_co: ...
class SupportsSub(Protocol[T_contra, T_co]):
    def __sub__(self, other: T_contra) -> T_co: ...
class SupportsMul(Protocol[T_contra, T_co]):
    def __mul__(self, other: T_contra) -> T_co: ...
class SupportsTrueDiv(Protocol[T_contra, T_co]):
    def __truediv__(self, other: T_contra) -> T_co: ...
class SupportsFloorDiv(Protocol[T_contra, T_co]):
    def __floordiv__(self, other: T_contra) -> T_co: ...
class SupportsMod(Protocol[T_contra, T_co]):
    def __mod__(self, other: T_contra) -> T_co: ...
class SupportsDivMod(Protocol[T_contra, T_co]):
    def __divmod__(self, other: T_contra) -> T_co: ...
class SupportsLShift(Protocol[T_contra, T_co]):
    def __lshift__(self, other: T_contra) -> T_co: ...
class SupportsRShift(Protocol[T_contra, T_co]):
    def __rshift__(self, other: T_contra) -> T_co: ...
class SupportsAnd(Protocol[T_contra, T_co]):
    def __and__(self, other: T_contra) -> T_co: ...
class SupportsXor(Protocol[T_contra, T_co]):
    def __xor__(self, other: T_contra) -> T_co: ...
class SupportsOr(Protocol[T_contra, T_co]):
    def __or__(self, other: T_contra) -> T_co: ...

class SupportsRAdd(Protocol[T_contra, T_co]):
    def __radd__(self, other: T_contra) -> T_co: ...
class SupportsRSub(Protocol[T_contra, T_co]):
    def __rsub__(self, other: T_contra) -> T_co: ...
class SupportsRMul(Protocol[T_contra, T_co]):
    def __rmul__(self, other: T_contra) -> T_co: ...
class SupportsRTrueDiv(Protocol[T_contra, T_co]):
    def __rtruediv__(self, other: T_contra) -> T_co: ...
class SupportsRFloorDiv(Protocol[T_contra, T_co]):
    def __rfloordiv__(self, other: T_contra) -> T_co: ...
class SupportsRMod(Protocol[T_contra, T_co]):
    def __rmod__(self, other: T_contra) -> T_co: ...
class SupportsRDivMod(Protocol[T_contra, T_co]):
    def __rdivmod__(self, other: T_contra) -> T_co: ...
class SupportsRLShift(Protocol[T_contra, T_co]):
    def __rlshift__(self, other: T_contra) -> T_co: ...
class SupportsRRShift(Protocol[T_contra, T_co]):
    def __rrshift__(self, other: T_contra) -> T_co: ...
class SupportsRAnd(Protocol[T_contra, T_co]):
    def __rand__(self, other: T_contra) -> T_co: ...
class SupportsRXor(Protocol[T_contra, T_co]):
    def __rxor__(self, other: T_contra) -> T_co: ...
class SupportsROr(Protocol[T_contra, T_co]):
    def __ror__(self, other: T_contra) -> T_co: ...

class SupportsNeg(Protocol[T_co]):
    def __neg__(self) -> T_co: ...
class SupportsPos(Protocol[T_co]):
    def __pos__(self) -> T_co: ...
class SupportsAbs(Protocol[T_co]):
    def __abs__(self) -> T_co: ...
class SupportsInvert(Protocol[T_co]):
    def __invert__(self) -> T_co: ...


def compare(a: MatrixLike, b: MatrixLike, /) -> Literal[-1, 0, 1]: ...

def __lt__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def __le__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def __eq__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def __ne__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def __gt__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def __ge__(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...

@overload
def __add__(a: MatrixLike[SupportsAdd[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __add__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRAdd[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __sub__(a: MatrixLike[SupportsSub[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __sub__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRSub[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __mul__(a: MatrixLike[SupportsMul[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __mul__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRMul[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __truediv__(a: MatrixLike[SupportsTrueDiv[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __truediv__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRTrueDiv[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __floordiv__(a: MatrixLike[SupportsFloorDiv[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __floordiv__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRFloorDiv[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __mod__(a: MatrixLike[SupportsMod[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __mod__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRMod[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __divmod__(a: MatrixLike[SupportsDivMod[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __divmod__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRDivMod[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __lshift__(a: MatrixLike[SupportsLShift[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __lshift__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRLShift[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __rshift__(a: MatrixLike[SupportsRShift[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __rshift__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRRShift[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
def __neg__(a: MatrixLike[SupportsNeg[T], M, N], /) -> MatrixMap[T, M, N]: ...
def __pos__(a: MatrixLike[SupportsPos[T], M, N], /) -> MatrixMap[T, M, N]: ...
def __abs__(a: MatrixLike[SupportsAbs[T], M, N], /) -> MatrixMap[T, M, N]: ...

@overload
def __and__(a: MatrixLike[SupportsAnd[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __and__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRAdd[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __xor__(a: MatrixLike[SupportsXor[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __xor__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRXor[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __or__(a: MatrixLike[SupportsOr[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def __or__(a: MatrixLike[S, M, N], b: MatrixLike[SupportsROr[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
def __invert__(a: MatrixLike[SupportsInvert[T], M, N], /) -> MatrixMap[T, M, N]: ...

def __matmul__(a: MatrixLike[ComplexT, M, N], b: MatrixLike[ComplexT, N, P], /) -> MatrixProduct[ComplexT, M, P]: ...
def conjugate(a: MatrixLike[ComplexT, M, N], /) -> MatrixMap[ComplexT, M, N]: ...
