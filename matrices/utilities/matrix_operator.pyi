from typing import Any, Literal, Protocol, TypeVar, overload

from ..abc import MatrixLike
from .matrix_map import MatrixMap

__all__ = [
    "cmp",
    "lt",
    "le",
    "eq",
    "ne",
    "gt",
    "ge",
    "add",
    "sub",
    "mul",
    "div",
    "quo",
    "rem",
    "quo_rem",
    "shl",
    "shr",
    "neg",
    "pos",
    "abs",
    "bit_and",
    "bit_xor",
    "bit_or",
    "bit_inv",
    "log_and",
    "log_xor",
    "log_or",
    "mat_mul",
    "conj",
]

S = TypeVar("S")

T = TypeVar("T")
T_co = TypeVar("T_co", covariant=True)
T_contra = TypeVar("T_contra", contravariant=True)

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)
P = TypeVar("P", bound=int)


class SupportsAdd(Protocol[T_contra, T_co]):
    def __add__(self, other: T_contra) -> T_co: ...
class SupportsSub(Protocol[T_contra, T_co]):
    def __sub__(self, other: T_contra) -> T_co: ...
class SupportsMul(Protocol[T_contra, T_co]):
    def __mul__(self, other: T_contra) -> T_co: ...
class SupportsTrueDiv(Protocol[T_contra, T_co]):
    def __truediv__(self, other: T_contra) -> T_co: ...
class SupportsFloorDiv(Protocol[T_contra, T_co]):
    def __floordiv__(self, other: T_contra) -> T_co: ...
class SupportsMod(Protocol[T_contra, T_co]):
    def __mod__(self, other: T_contra) -> T_co: ...
class SupportsDivMod(Protocol[T_contra, T_co]):
    def __divmod__(self, other: T_contra) -> T_co: ...
class SupportsLShift(Protocol[T_contra, T_co]):
    def __lshift__(self, other: T_contra) -> T_co: ...
class SupportsRShift(Protocol[T_contra, T_co]):
    def __rshift__(self, other: T_contra) -> T_co: ...
class SupportsAnd(Protocol[T_contra, T_co]):
    def __and__(self, other: T_contra) -> T_co: ...
class SupportsXor(Protocol[T_contra, T_co]):
    def __xor__(self, other: T_contra) -> T_co: ...
class SupportsOr(Protocol[T_contra, T_co]):
    def __or__(self, other: T_contra) -> T_co: ...

class SupportsRAdd(Protocol[T_contra, T_co]):
    def __radd__(self, other: T_contra) -> T_co: ...
class SupportsRSub(Protocol[T_contra, T_co]):
    def __rsub__(self, other: T_contra) -> T_co: ...
class SupportsRMul(Protocol[T_contra, T_co]):
    def __rmul__(self, other: T_contra) -> T_co: ...
class SupportsRTrueDiv(Protocol[T_contra, T_co]):
    def __rtruediv__(self, other: T_contra) -> T_co: ...
class SupportsRFloorDiv(Protocol[T_contra, T_co]):
    def __rfloordiv__(self, other: T_contra) -> T_co: ...
class SupportsRMod(Protocol[T_contra, T_co]):
    def __rmod__(self, other: T_contra) -> T_co: ...
class SupportsRDivMod(Protocol[T_contra, T_co]):
    def __rdivmod__(self, other: T_contra) -> T_co: ...
class SupportsRLShift(Protocol[T_contra, T_co]):
    def __rlshift__(self, other: T_contra) -> T_co: ...
class SupportsRRShift(Protocol[T_contra, T_co]):
    def __rrshift__(self, other: T_contra) -> T_co: ...
class SupportsRAnd(Protocol[T_contra, T_co]):
    def __rand__(self, other: T_contra) -> T_co: ...
class SupportsRXor(Protocol[T_contra, T_co]):
    def __rxor__(self, other: T_contra) -> T_co: ...
class SupportsROr(Protocol[T_contra, T_co]):
    def __ror__(self, other: T_contra) -> T_co: ...

class SupportsNeg(Protocol[T_co]):
    def __neg__(self) -> T_co: ...
class SupportsPos(Protocol[T_co]):
    def __pos__(self) -> T_co: ...
class SupportsAbs(Protocol[T_co]):
    def __abs__(self) -> T_co: ...
class SupportsInvert(Protocol[T_co]):
    def __invert__(self) -> T_co: ...
class SupportsConjugate(Protocol[T_co]):
    def conjugate(self) -> T_co: ...


def cmp(a: MatrixLike, b: MatrixLike, /) -> Literal[-1, 0, 1]: ...

def lt(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def le(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def eq(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def ne(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def gt(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def ge(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...

@overload
def add(a: MatrixLike[SupportsAdd[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def add(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRAdd[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def sub(a: MatrixLike[SupportsSub[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def sub(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRSub[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def mul(a: MatrixLike[SupportsMul[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def mul(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRMul[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def div(a: MatrixLike[SupportsTrueDiv[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def div(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRTrueDiv[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def quo(a: MatrixLike[SupportsFloorDiv[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def quo(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRFloorDiv[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def rem(a: MatrixLike[SupportsMod[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def rem(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRMod[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def quo_rem(a: MatrixLike[SupportsDivMod[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def quo_rem(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRDivMod[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def shl(a: MatrixLike[SupportsLShift[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def shl(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRLShift[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def shr(a: MatrixLike[SupportsRShift[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def shr(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRRShift[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
def neg(a: MatrixLike[SupportsNeg[T], M, N], /) -> MatrixMap[T, M, N]: ...
def pos(a: MatrixLike[SupportsPos[T], M, N], /) -> MatrixMap[T, M, N]: ...
def abs(a: MatrixLike[SupportsAbs[T], M, N], /) -> MatrixMap[T, M, N]: ...

@overload
def bit_and(a: MatrixLike[SupportsAnd[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def bit_and(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRAdd[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def bit_xor(a: MatrixLike[SupportsXor[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def bit_xor(a: MatrixLike[S, M, N], b: MatrixLike[SupportsRXor[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def bit_or(a: MatrixLike[SupportsOr[S, T], M, N], b: MatrixLike[S, M, N], /) -> MatrixMap[T, M, N]: ...
@overload
def bit_or(a: MatrixLike[S, M, N], b: MatrixLike[SupportsROr[S, T], M, N], /) -> MatrixMap[T, M, N]: ...
def bit_inv(a: MatrixLike[SupportsInvert[T], M, N], /) -> MatrixMap[T, M, N]: ...

def log_and(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def log_xor(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def log_or(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def log_inv(a: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...

def mat_mul(a: MatrixLike[Any, M, N], b: MatrixLike[Any, N, P], /): ...
def conj(a: MatrixLike[SupportsConjugate[T], M, N], /) -> MatrixMap[T, M, N]: ...
