from typing import Any, Protocol, TypeVar

from ..abc import MatrixLike
from .matrix_map import MatrixMap

__all__ = [
    "abs",
    "divmod",
    "add",
    "bitwise_and",
    "equal",
    "floordiv",
    "greater_equal",
    "greater",
    "invert",
    "lesser_equal",
    "lshift",
    "lesser",
    "mod",
    "mul",
    "not_equal",
    "neg",
    "bitwise_or",
    "pos",
    "rshift",
    "sub",
    "truediv",
    "bitwise_xor",
    "logical_and",
    "logical_or",
    "logical_not",
    "conjugate",
]

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)

T_co = TypeVar("T_co", covariant=True)

M_co = TypeVar("M_co", covariant=True, bound=int)
N_co = TypeVar("N_co", covariant=True, bound=int)


class SupportsNeg(Protocol[T_co]):
    def __neg__(self) -> T_co: ...
class SupportsPos(Protocol[T_co]):
    def __pos__(self) -> T_co: ...
class SupportsAbs(Protocol[T_co]):
    def __abs__(self) -> T_co: ...
class SupportsInvert(Protocol[T_co]):
    def __invert__(self) -> T_co: ...
class SupportsConjugate(Protocol[T_co]):
    def conjugate(self) -> T_co: ...


def abs(a: MatrixLike[SupportsAbs[T], M, N], /) -> MatrixMap[T, M, N]: ...
def divmod(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def add(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def bitwise_and(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def equal(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def floordiv(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def greater_equal(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def greater(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def invert(a: MatrixLike[SupportsInvert[T], M, N], /) -> MatrixMap[T, M, N]: ...
def lesser_equal(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def lshift(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def lesser(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def mod(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def mul(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def not_equal(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def neg(a: MatrixLike[SupportsNeg[T], M, N], /) -> MatrixMap[T, M, N]: ...
def bitwise_or(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def pos(a: MatrixLike[SupportsPos[T], M, N], /) -> MatrixMap[T, M, N]: ...
def rshift(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def sub(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def truediv(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def bitwise_xor(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[Any, M, N]: ...
def logical_and(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def logical_or(a: MatrixLike[Any, M, N], b: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def logical_not(a: MatrixLike[Any, M, N], /) -> MatrixMap[bool, M, N]: ...
def conjugate(a: MatrixLike[SupportsConjugate[T], M, N], /) -> MatrixMap[T, M, N]: ...
