from abc import ABCMeta, abstractmethod
from collections.abc import Iterable, Iterator, Sequence
from typing import (Any, Generic, Literal, SupportsIndex, TypeVar, Union,
                    overload)

from .rule import Rule

__all__ = ["MatrixLike"]

T_co = TypeVar("T_co", covariant=True)

M_co = TypeVar("M_co", bound=int, covariant=True)
N_co = TypeVar("N_co", bound=int, covariant=True)


class MatrixLike(Sequence[T_co], Generic[T_co, M_co, N_co], metaclass=ABCMeta):

    __slots__: tuple[()]
    __match_args__: tuple[Literal["array"], Literal["shape"]]

    def __len__(self) -> int: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: int) -> T_co: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: slice) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: tuple[int, int]) -> T_co: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: tuple[int, slice]) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: tuple[slice, int]) -> MatrixLike[T_co, Any, Literal[1]]: ...
    @overload
    @abstractmethod
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T_co, Any, Any]: ...

    @property
    @abstractmethod
    def array(self) -> Sequence[T_co]: ...
    @property
    @abstractmethod
    def shape(self) -> tuple[M_co, N_co]: ...
    @property
    def nrows(self) -> M_co: ...
    @property
    def ncols(self) -> N_co: ...
    @property
    def size(self) -> int: ...

    @abstractmethod
    def equal(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    @abstractmethod
    def not_equal(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    @abstractmethod
    def logical_and(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    @abstractmethod
    def logical_or(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    @abstractmethod
    def logical_not(self) -> MatrixLike[bool, M_co, N_co]: ...
    @abstractmethod
    def transpose(self) -> MatrixLike[T_co, N_co, M_co]: ...
    @abstractmethod
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T_co, M_co, N_co]: ...
    @abstractmethod
    def reverse(self) -> MatrixLike[T_co, M_co, N_co]: ...
    @overload
    def n(self, by: Literal[Rule.ROW]) -> M_co: ...
    @overload
    def n(self, by: Literal[Rule.COL]) -> N_co: ...
    @overload
    def n(self, by: Rule) -> Union[M_co, N_co]: ...
    def values(self, *, by: Rule = Rule.ROW, reverse: bool = False) -> Iterator[T_co]: ...
    @overload
    def slices(self, *, by: Literal[Rule.ROW], reverse: bool = False) -> Iterator[MatrixLike[T_co, Literal[1], N_co]]: ...
    @overload
    def slices(self, *, by: Literal[Rule.COL], reverse: bool = False) -> Iterator[MatrixLike[T_co, M_co, Literal[1]]]: ...
    @overload
    def slices(self, *, by: Rule, reverse: bool = False) -> Iterator[MatrixLike[T_co, Any, Any]]: ...
    @overload
    def slices(self, *, reverse: bool = False) -> Iterator[MatrixLike[T_co, Literal[1], N_co]]: ...

    def _resolve_vector_index(self, key: SupportsIndex) -> int: ...
    def _resolve_matrix_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def _resolve_vector_slice(self, key: slice) -> Iterable[int]: ...
    def _resolve_matrix_slice(self, key: slice, *, by: Rule = Rule.ROW) -> Iterable[int]: ...
