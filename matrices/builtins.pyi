from collections.abc import Iterable, Sequence
from typing import Any, Literal, Optional, SupportsIndex, TypeVar, overload

from .abc import (ComplexMatrixLike, IntegralMatrixLike, MatrixLike,
                  RealMatrixLike)
from .rule import Rule

__all__ = [
    "Matrix",
    "ComplexMatrix",
    "RealMatrix",
    "IntegralMatrix",
]

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)
P = TypeVar("P", bound=int)

T_co = TypeVar("T_co", covariant=True)

M_co = TypeVar("M_co", covariant=True, bound=int)
N_co = TypeVar("N_co", covariant=True, bound=int)
P_co = TypeVar("P_co", covariant=True, bound=int)

ComplexT_co = TypeVar("ComplexT_co", covariant=True, bound=complex)
RealT_co = TypeVar("RealT_co", covariant=True, bound=float)
IntegralT_co = TypeVar("IntegralT_co", covariant=True, bound=int)

MatrixT = TypeVar("MatrixT", bound=Matrix)


class Matrix(MatrixLike[T_co, M_co, N_co]):

    __slots__: tuple[Literal["_array"], Literal["_shape"]]

    @overload
    def __init__(self, array: MatrixLike[T_co, M_co, N_co]) -> None: ...
    @overload
    def __init__(self, array: Optional[Iterable[T_co]] = None, shape: Optional[tuple[Optional[M_co], Optional[N_co]]] = None) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> T_co: ...
    @overload
    def __getitem__(self, key: slice) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> T_co: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, slice]) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, SupportsIndex]) -> MatrixLike[T_co, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T_co, Any, Any]: ...
    def __deepcopy__(self: MatrixT, memo: Optional[dict[int, Any]] = None) -> MatrixT: ...
    def __copy__(self: MatrixT) -> MatrixT: ...

    @classmethod
    def wrap(cls: type[MatrixT], array: list[T_co], shape: tuple[M_co, N_co]) -> MatrixT: ...
    @classmethod
    def fold(cls: type[MatrixT], rows: Iterable[Iterable[T_co]]) -> MatrixT: ...

    @property
    def array(self) -> Sequence[T_co]: ...
    @property
    def shape(self) -> tuple[M_co, N_co]: ...

    def equal(self, other: MatrixLike[Any, M_co, N_co]) -> IntegralMatrixLike[bool, M_co, N_co]: ...
    def not_equal(self, other: MatrixLike[Any, M_co, N_co]) -> IntegralMatrixLike[bool, M_co, N_co]: ...
    def logical_and(self, other: MatrixLike[Any, M_co, N_co]) -> IntegralMatrixLike[bool, M_co, N_co]: ...
    def logical_or(self, other: MatrixLike[Any, M_co, N_co]) -> IntegralMatrixLike[bool, M_co, N_co]: ...
    def logical_not(self) -> IntegralMatrixLike[bool, M_co, N_co]: ...
    def transpose(self) -> MatrixLike[T_co, N_co, M_co]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T_co, M_co, N_co]: ...
    def reverse(self) -> MatrixLike[T_co, M_co, N_co]: ...
