from collections.abc import Iterable, Sequence
from typing import Any, Literal, Optional, SupportsIndex, TypeVar, overload

from .abc import MatrixLike
from .rule import Rule

__all__ = ["FrozenMatrix"]

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)

T_co = TypeVar("T_co", covariant=True)

M_co = TypeVar("M_co", covariant=True, bound=int)
N_co = TypeVar("N_co", covariant=True, bound=int)

FrozenMatrixT = TypeVar("FrozenMatrixT", bound=FrozenMatrix)


class FrozenMatrix(MatrixLike[T_co, M_co, N_co]):

    __slots__: tuple[Literal["_array"], Literal["_shape"]]

    @overload
    def __init__(self, array: MatrixLike[T_co, M_co, N_co]) -> None: ...
    @overload
    def __init__(self, array: Optional[Iterable[T_co]] = None, shape: Optional[tuple[Optional[M_co], Optional[N_co]]] = None) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> T_co: ...
    @overload
    def __getitem__(self, key: slice) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> T_co: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, slice]) -> MatrixLike[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, SupportsIndex]) -> MatrixLike[T_co, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T_co, Any, Any]: ...
    def __deepcopy__(self: FrozenMatrixT, memo: Optional[dict[int, Any]] = None) -> FrozenMatrixT: ...
    def __copy__(self: FrozenMatrixT) -> FrozenMatrixT: ...

    @classmethod
    def wrap(cls: type[FrozenMatrixT], array: list[T_co], shape: tuple[M_co, N_co]) -> FrozenMatrixT: ...
    @classmethod
    def fold(cls: type[FrozenMatrixT], rows: Iterable[Iterable[T_co]]) -> FrozenMatrixT: ...

    @property
    def array(self) -> Sequence[T_co]: ...
    @property
    def shape(self) -> tuple[M_co, N_co]: ...

    def equal(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    def not_equal(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    def logical_and(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    def logical_or(self, other: MatrixLike[Any, M_co, N_co]) -> MatrixLike[bool, M_co, N_co]: ...
    def logical_not(self) -> MatrixLike[bool, M_co, N_co]: ...
    def transpose(self) -> MatrixLike[T_co, N_co, M_co]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T_co, M_co, N_co]: ...
    def reverse(self) -> MatrixLike[T_co, M_co, N_co]: ...
