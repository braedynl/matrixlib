from collections.abc import Iterable, MutableSequence
from typing import (Any, Literal, Optional, SupportsIndex, TypeVar, Union,
                    overload)

from .abc import MatrixLike
from .rule import Rule
from .shapes.abc import ShapeLike
from .shapes.builtins import Shape
from .typeshed import (SupportsAbs, SupportsAdd, SupportsAnd,
                       SupportsClosedAdd, SupportsDivMod, SupportsDotProduct,
                       SupportsFloorDiv, SupportsInvert, SupportsLShift,
                       SupportsMod, SupportsMul, SupportsNeg, SupportsOr,
                       SupportsPos, SupportsPow, SupportsRAdd, SupportsRAnd,
                       SupportsRDivMod, SupportsRDotProduct, SupportsRFloorDiv,
                       SupportsRLShift, SupportsRMod, SupportsRMul,
                       SupportsROr, SupportsRPow, SupportsRRShift,
                       SupportsRShift, SupportsRSub, SupportsRTrueDiv,
                       SupportsRXor, SupportsSub, SupportsTrueDiv, SupportsXor)

__all__ = ["FrozenMatrix", "Matrix"]

T1 = TypeVar("T1")
T2 = TypeVar("T2")

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)
P = TypeVar("P", bound=int)

T_co = TypeVar("T_co", covariant=True)

M_co = TypeVar("M_co", covariant=True, bound=int)
N_co = TypeVar("N_co", covariant=True, bound=int)
P_co = TypeVar("P_co", covariant=True, bound=int)

SupportsClosedAddT = TypeVar("SupportsClosedAddT", bound=SupportsClosedAdd)
FrozenMatrixT = TypeVar("FrozenMatrixT", bound=FrozenMatrix)
MatrixT = TypeVar("MatrixT", bound=Matrix)


class FrozenMatrix(MatrixLike[T_co, M_co, N_co]):

    __slots__: tuple[Literal["_array"], Literal["_shape"]]

    @overload
    def __init__(self, array: Optional[Iterable[T_co]] = None, shape: Optional[tuple[Optional[M_co], Optional[N_co]]] = None) -> None: ...
    @overload
    def __init__(self, array: Optional[Iterable[T_co]] = None, shape: Optional[ShapeLike[M_co, N_co]] = None) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> T_co: ...
    @overload
    def __getitem__(self, key: slice) -> FrozenMatrix[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> T_co: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, slice]) -> FrozenMatrix[T_co, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, SupportsIndex]) -> FrozenMatrix[T_co, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> FrozenMatrix[T_co, Any, Any]: ...
    @overload
    def __add__(self: MatrixLike[SupportsAdd[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __add__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRAdd[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __sub__(self: MatrixLike[SupportsSub[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __sub__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRSub[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __mul__(self: MatrixLike[SupportsMul[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __mul__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRMul[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __truediv__(self: MatrixLike[SupportsTrueDiv[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __truediv__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRTrueDiv[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[SupportsFloorDiv[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRFloorDiv[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __mod__(self: MatrixLike[SupportsMod[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __mod__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRMod[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __divmod__(self: MatrixLike[SupportsDivMod[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __divmod__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRDivMod[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __pow__(self: MatrixLike[SupportsPow[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __pow__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRPow[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __lshift__(self: MatrixLike[SupportsLShift[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __lshift__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRLShift[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __rshift__(self: MatrixLike[SupportsRShift[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __rshift__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRRShift[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __and__(self: MatrixLike[SupportsAnd[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __and__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRAnd[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __xor__(self: MatrixLike[SupportsXor[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __xor__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRXor[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __or__(self: MatrixLike[SupportsOr[T1, T2], M_co, N_co], other: MatrixLike[T1, M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __or__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsROr[T1, T2], M_co, N_co]) -> FrozenMatrix[T2, M_co, N_co]: ...
    @overload
    def __matmul__(self: MatrixLike[SupportsDotProduct[T1, SupportsClosedAddT], M_co, N_co], other: MatrixLike[T1, N_co, P_co]) -> FrozenMatrix[SupportsClosedAddT, M_co, P_co]: ...
    @overload
    def __matmul__(self: MatrixLike[T1, M_co, N_co], other: MatrixLike[SupportsRDotProduct[T1, SupportsClosedAddT], N_co, P_co]) -> FrozenMatrix[SupportsClosedAddT, M_co, P_co]: ...
    def __neg__(self: MatrixLike[SupportsNeg[T1], M_co, N_co]) -> FrozenMatrix[T1, M_co, N_co]: ...
    def __pos__(self: MatrixLike[SupportsPos[T1], M_co, N_co]) -> FrozenMatrix[T1, M_co, N_co]: ...
    def __abs__(self: MatrixLike[SupportsAbs[T1], M_co, N_co]) -> FrozenMatrix[T1, M_co, N_co]: ...
    def __invert__(self: MatrixLike[SupportsInvert[T1], M_co, N_co]) -> FrozenMatrix[T1, M_co, N_co]: ...
    def __deepcopy__(self: FrozenMatrixT, memo: Optional[dict[int, Any]] = None) -> FrozenMatrixT: ...
    def __copy__(self: FrozenMatrixT) -> FrozenMatrixT: ...

    @classmethod
    def wrap(cls: type[FrozenMatrixT], array: MutableSequence[T_co], shape: Shape[M_co, N_co]) -> FrozenMatrixT: ...
    @classmethod
    def fill(cls: type[FrozenMatrixT], value: T_co, shape: Union[tuple[M_co, N_co], ShapeLike[M_co, N_co]]) -> FrozenMatrixT: ...  # type: ignore[misc]
    @classmethod
    def infer(cls: type[FrozenMatrixT], rows: Iterable[Iterable[T_co]]) -> FrozenMatrixT: ...

    @property
    def shape(self) -> Shape[M_co, N_co]: ...

    def lesser(self, other: MatrixLike[T_co, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def lesser_equal(self, other: MatrixLike[T_co, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def equal(self, other: MatrixLike[Any, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def not_equal(self, other: MatrixLike[Any, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def greater(self, other: MatrixLike[T_co, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def greater_equal(self, other: MatrixLike[T_co, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def logical_and(self, other: MatrixLike[Any, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def logical_or(self, other: MatrixLike[Any, M_co, N_co]) -> FrozenMatrix[bool, M_co, N_co]: ...
    def logical_not(self) -> FrozenMatrix[bool, M_co, N_co]: ...
    def transpose(self) -> MatrixLike[T_co, N_co, M_co]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T_co, M_co, N_co]: ...
    def reverse(self) -> MatrixLike[T_co, M_co, N_co]: ...


class Matrix(FrozenMatrix[T, M, N]):

    __slots__: tuple[()]

    def copy(self: MatrixT) -> MatrixT: ...
    @overload
    def stack(self, other: MatrixLike[T, Any, N], *, by: Literal[Rule.ROW]) -> Matrix[T, Any, N]: ...
    @overload
    def stack(self, other: MatrixLike[T, M, Any], *, by: Literal[Rule.COL]) -> Matrix[T, M, Any]: ...
    @overload
    def stack(self, other: MatrixLike[T, Any, Any], *, by: Rule) -> Matrix[T, Any, Any]: ...
    @overload
    def stack(self, other: MatrixLike[T, Any, N]) -> Matrix[T, Any, N]: ...
