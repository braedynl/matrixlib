from collections.abc import Sequence
from typing import Any, Literal, TypeVar, overload

from ..abc import MatrixLike, IntegralMatrixLike
from ..rule import Rule
from .abc import MatrixViewLike

__all__ = [
    "MatrixView",
    "MatrixTransform",
    "MatrixTranspose",
    "MatrixRowFlip",
    "MatrixColFlip",
    "MatrixReverse",
]

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)


class MatrixView(MatrixViewLike[T, M, N]):

    __slots__: tuple[Literal["_target"]]

    def __init__(self, target: MatrixLike[T, M, N]) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: int) -> T: ...
    @overload
    def __getitem__(self, key: slice) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> T: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> MatrixLike[T, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T, Any, Any]: ...

    @property
    def array(self) -> Sequence[T]: ...
    @property
    def shape(self) -> tuple[M, N]: ...

    def equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def not_equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_and(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_or(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_not(self) -> IntegralMatrixLike[bool, M, N]: ...
    def transpose(self) -> MatrixLike[T, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T, M, N]: ...
    def reverse(self) -> MatrixLike[T, M, N]: ...


class MatrixTransform(MatrixViewLike[T, M, N]):

    __slots__: tuple[Literal["_target"]]

    def __init__(self, target: MatrixLike[T, M, N]) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: int) -> T: ...
    @overload
    def __getitem__(self, key: slice) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> T: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> MatrixLike[T, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T, Any, Any]: ...

    @property
    def array(self) -> Sequence[T]: ...
    @property
    def shape(self) -> tuple[M, N]: ...

    def equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def not_equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_and(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_or(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def logical_not(self) -> IntegralMatrixLike[bool, M, N]: ...
    def transpose(self) -> MatrixLike[T, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T, M, N]: ...
    def reverse(self) -> MatrixLike[T, M, N]: ...

    def _permute_vector_index(self, val_index: int) -> int: ...
    def _permute_matrix_index(self, row_index: int, col_index: int) -> int: ...


class MatrixTranspose(MatrixTransform[T, M, N]):

    __slots__: tuple[()]

    def __init__(self, target: MatrixLike[T, N, M]) -> None: ...


class MatrixRowFlip(MatrixTransform[T, M, N]):

    __slots__: tuple[()]


class MatrixColFlip(MatrixTransform[T, M, N]):

    __slots__: tuple[()]


class MatrixReverse(MatrixTransform[T, M, N]):

    __slots__: tuple[()]
