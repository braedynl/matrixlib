from collections.abc import Sequence
from typing import Any, Literal, Optional, TypeVar, Union, overload

from ..abc import (ComplexMatrixLike, IntegralMatrixLike, MatrixLike,
                   RealMatrixLike)
from ..rule import Rule
from .abc import MatrixViewLike

T = TypeVar("T")

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)
P = TypeVar("P", bound=int)

ComplexT = TypeVar("ComplexT", bound=complex)
RealT = TypeVar("RealT", bound=float)
IntegralT = TypeVar("IntegralT", bound=int)

MatrixViewT = TypeVar("MatrixViewT", bound=MatrixView)


class MatrixView(MatrixViewLike[T, M, N]):

    __slots__: tuple[Literal["_target"]]

    @overload
    def __getitem__(self, key: int) -> T: ...
    @overload
    def __getitem__(self, key: slice) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> T: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> MatrixLike[T, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> MatrixLike[T, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> MatrixLike[T, Any, Any]: ...

    def __init__(self, target: MatrixLike[T, M, N]) -> None: ...
    def __repr__(self) -> str: ...
    def __deepcopy__(self: MatrixViewT, memo: Optional[dict[int, Any]] = None) -> MatrixViewT: ...
    def __copy__(self: MatrixViewT) -> MatrixViewT: ...

    @property
    def array(self) -> Sequence[T]: ...
    @property
    def shape(self) -> tuple[M, N]: ...

    def equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def not_equal(self, other: MatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def transpose(self) -> MatrixLike[T, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> MatrixLike[T, M, N]: ...
    def reverse(self) -> MatrixLike[T, M, N]: ...


class ComplexMatrixView(ComplexMatrixLike[ComplexT, M, N], MatrixView[ComplexT, M, N]):

    __slots__: tuple[()]

    @overload
    def __getitem__(self, key: int) -> ComplexT: ...
    @overload
    def __getitem__(self, key: slice) -> ComplexMatrixLike[ComplexT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> ComplexT: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> ComplexMatrixLike[ComplexT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> ComplexMatrixLike[ComplexT, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> ComplexMatrixLike[ComplexT, Any, Any]: ...

    @overload
    def __add__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __add__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __add__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __sub__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __sub__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __sub__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __mul__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __mul__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __mul__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __matmul__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, N, P]) -> ComplexMatrixLike[complex, M, P]: ...
    @overload
    def __matmul__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, N, P]) -> ComplexMatrixLike[complex, M, P]: ...
    @overload
    def __matmul__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, N, P]) -> ComplexMatrixLike[complex, M, P]: ...
    @overload
    def __truediv__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __truediv__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __truediv__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __radd__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __radd__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __radd__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rsub__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rsub__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rsub__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rmul__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rmul__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rmul__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rmatmul__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, P, M]) -> ComplexMatrixLike[complex, P, N]: ...
    @overload
    def __rmatmul__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, P, M]) -> ComplexMatrixLike[complex, P, N]: ...
    @overload
    def __rmatmul__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, P, M]) -> ComplexMatrixLike[complex, P, N]: ...
    @overload
    def __rtruediv__(self: ComplexMatrixLike[complex, M, N], other: IntegralMatrixLike[int, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rtruediv__(self: ComplexMatrixLike[complex, M, N], other: RealMatrixLike[float, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    @overload
    def __rtruediv__(self: ComplexMatrixLike[complex, M, N], other: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    def __neg__(self: ComplexMatrixLike[complex, M, N]) -> ComplexMatrixLike[complex, M, N]: ...
    def __abs__(self: ComplexMatrixLike[complex, M, N]) -> RealMatrixLike[float, M, N]: ...

    def __init__(self, target: ComplexMatrixLike[ComplexT, M, N]) -> None: ...

    def transpose(self) -> ComplexMatrixLike[ComplexT, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> ComplexMatrixLike[ComplexT, M, N]: ...
    def reverse(self) -> ComplexMatrixLike[ComplexT, M, N]: ...

    def conjugate(self) -> ComplexMatrixLike[ComplexT, M, N]: ...


class RealMatrixView(RealMatrixLike[RealT, M, N], MatrixView[RealT, M, N]):

    __slots__: tuple[()]

    @overload
    def __getitem__(self, key: int) -> RealT: ...
    @overload
    def __getitem__(self, key: slice) -> RealMatrixLike[RealT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> RealT: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> RealMatrixLike[RealT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> RealMatrixLike[RealT, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> RealMatrixLike[RealT, Any, Any]: ...

    def __lt__(self, other: Union[RealMatrixLike, IntegralMatrixLike]) -> bool: ...
    def __le__(self, other: Union[RealMatrixLike, IntegralMatrixLike]) -> bool: ...
    def __gt__(self, other: Union[RealMatrixLike, IntegralMatrixLike]) -> bool: ...
    def __ge__(self, other: Union[RealMatrixLike, IntegralMatrixLike]) -> bool: ...
    @overload
    def __add__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __add__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __sub__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __sub__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __mul__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __mul__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __matmul__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, N, P]) -> RealMatrixLike[float, M, P]: ...
    @overload
    def __matmul__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, N, P]) -> RealMatrixLike[float, M, P]: ...
    @overload
    def __truediv__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __truediv__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __floordiv__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __floordiv__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __mod__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __mod__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __divmod__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> MatrixLike[tuple[float, float], M, N]: ...
    @overload
    def __divmod__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> MatrixLike[tuple[float, float], M, N]: ...
    @overload
    def __radd__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __radd__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rsub__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rsub__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rmul__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rmul__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rmatmul__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, P, M]) -> RealMatrixLike[float, P, N]: ...
    @overload
    def __rmatmul__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, P, M]) -> RealMatrixLike[float, P, N]: ...
    @overload
    def __rtruediv__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rtruediv__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rfloordiv__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rfloordiv__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rmod__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rmod__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    @overload
    def __rdivmod__(self: RealMatrixLike[float, M, N], other: IntegralMatrixLike[int, M, N]) -> MatrixLike[tuple[float, float], M, N]: ...
    @overload
    def __rdivmod__(self: RealMatrixLike[float, M, N], other: RealMatrixLike[float, M, N]) -> MatrixLike[tuple[float, float], M, N]: ...
    def __neg__(self: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...
    def __abs__(self: RealMatrixLike[float, M, N]) -> RealMatrixLike[float, M, N]: ...

    def __init__(self, target: RealMatrixLike[RealT, M, N]) -> None: ...

    def transpose(self) -> RealMatrixLike[RealT, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> RealMatrixLike[RealT, M, N]: ...
    def reverse(self) -> RealMatrixLike[RealT, M, N]: ...

    @overload
    def lesser(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def lesser(self, other: RealMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def lesser_equal(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def lesser_equal(self, other: RealMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def greater(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def greater(self, other: RealMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def greater_equal(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    @overload
    def greater_equal(self, other: RealMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...


class IntegralMatrixView(IntegralMatrixLike[IntegralT, M, N], MatrixView[IntegralT, M, N]):

    __slots__: tuple[()]

    @overload
    def __getitem__(self, key: int) -> IntegralT: ...
    @overload
    def __getitem__(self, key: slice) -> IntegralMatrixLike[IntegralT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[int, int]) -> IntegralT: ...
    @overload
    def __getitem__(self, key: tuple[int, slice]) -> IntegralMatrixLike[IntegralT, Literal[1], Any]: ...
    @overload
    def __getitem__(self, key: tuple[slice, int]) -> IntegralMatrixLike[IntegralT, Any, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> IntegralMatrixLike[IntegralT, Any, Any]: ...

    def __lt__(self, other: IntegralMatrixLike) -> bool: ...
    def __le__(self, other: IntegralMatrixLike) -> bool: ...
    def __gt__(self, other: IntegralMatrixLike) -> bool: ...
    def __ge__(self, other: IntegralMatrixLike) -> bool: ...
    def __add__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __sub__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __mul__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __matmul__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, N, P]) -> IntegralMatrixLike[int, M, P]: ...
    def __truediv__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    def __floordiv__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __mod__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __divmod__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> MatrixLike[tuple[int, int], M, N]: ...
    def __lshift__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rshift__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __and__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __xor__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __or__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __radd__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rsub__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rmul__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rmatmul__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, P, M]) -> IntegralMatrixLike[int, P, N]: ...
    def __rtruediv__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> RealMatrixLike[float, M, N]: ...
    def __rfloordiv__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rmod__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rdivmod__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> MatrixLike[tuple[int, int], M, N]: ...
    def __rlshift__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rrshift__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rand__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __rxor__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __ror__(self: IntegralMatrixLike[int, M, N], other: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __neg__(self: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __abs__(self: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...
    def __invert__(self: IntegralMatrixLike[int, M, N]) -> IntegralMatrixLike[int, M, N]: ...

    def __init__(self, target: IntegralMatrixLike[IntegralT, M, N]) -> None: ...

    def transpose(self) -> IntegralMatrixLike[IntegralT, N, M]: ...
    def flip(self, *, by: Rule = Rule.ROW) -> IntegralMatrixLike[IntegralT, M, N]: ...
    def reverse(self) -> IntegralMatrixLike[IntegralT, M, N]: ...

    def lesser(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def lesser_equal(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def greater(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
    def greater_equal(self, other: IntegralMatrixLike[Any, M, N]) -> IntegralMatrixLike[bool, M, N]: ...
